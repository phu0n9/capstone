{"version":3,"file":"react-infinite-scroll-hook.cjs.production.min.js","sources":["../src/useInfiniteScroll.ts"],"sourcesContent":["import { useEffect } from 'react';\r\nimport {\r\n  useTrackVisibility,\r\n  IntersectionObserverHookArgs,\r\n  IntersectionObserverHookRefCallback,\r\n  IntersectionObserverHookRootRefCallback,\r\n} from 'react-intersection-observer-hook';\r\n\r\nconst DEFAULT_DELAY_IN_MS = 100;\r\n\r\nexport type UseInfiniteScrollHookResult = [\r\n  IntersectionObserverHookRefCallback,\r\n  { rootRef: IntersectionObserverHookRootRefCallback },\r\n];\r\n\r\nexport type UseInfiniteScrollHookArgs = Pick<\r\n  IntersectionObserverHookArgs,\r\n  // We pass this to 'IntersectionObserver'. We can use it to configure when to trigger 'onLoadMore'.\r\n  'rootMargin'\r\n> & {\r\n  // Some sort of \"is fetching\" info of the request.\r\n  loading: boolean;\r\n  // If the list has more items to load.\r\n  hasNextPage: boolean;\r\n  // The callback function to execute when the 'onLoadMore' is triggered.\r\n  // eslint-disable-next-line no-undef\r\n  onLoadMore: VoidFunction;\r\n  // Flag to stop infinite scrolling. Can be used in case of an error etc too.\r\n  disabled?: boolean;\r\n  // How long it should wait before triggering 'onLoadMore'.\r\n  delayInMs?: number;\r\n};\r\n\r\nfunction useInfiniteScroll({\r\n  loading,\r\n  hasNextPage,\r\n  onLoadMore,\r\n  rootMargin,\r\n  disabled,\r\n  delayInMs = DEFAULT_DELAY_IN_MS,\r\n}: UseInfiniteScrollHookArgs): UseInfiniteScrollHookResult {\r\n  const [ref, { rootRef, isVisible }] = useTrackVisibility({\r\n    rootMargin,\r\n  });\r\n\r\n  const shouldLoadMore = !disabled && !loading && isVisible && hasNextPage;\r\n\r\n  // eslint-disable-next-line consistent-return\r\n  useEffect(() => {\r\n    if (shouldLoadMore) {\r\n      // When we trigger 'onLoadMore' and new items are added to the list,\r\n      // right before they become rendered on the screen, 'loading' becomes false\r\n      // and 'isVisible' can be true for a brief time, based on the scroll position.\r\n      // So, it triggers 'onLoadMore' just after the first one is finished.\r\n      // We use a small delay here to prevent this kind of situations.\r\n      // It can be configured by hook args.\r\n      const timer = setTimeout(() => {\r\n        onLoadMore();\r\n      }, delayInMs);\r\n      return () => {\r\n        clearTimeout(timer);\r\n      };\r\n    }\r\n  }, [onLoadMore, shouldLoadMore, delayInMs]);\r\n\r\n  return [ref, { rootRef }];\r\n}\r\n\r\nexport default useInfiniteScroll;\r\n"],"names":["loading","hasNextPage","onLoadMore","disabled","delayInMs","useTrackVisibility","rootMargin","ref","rootRef","shouldLoadMore","isVisible","useEffect","timer","setTimeout","clearTimeout"],"mappings":"yJAiCA,gBACEA,IAAAA,QACAC,IAAAA,YACAC,IAAAA,WAEAC,IAAAA,aACAC,UAAAA,aA/B0B,QAiCYC,qBAAmB,CACvDC,aALFA,aAIOC,cAAOC,IAAAA,QAIRC,GAAkBN,IAAaH,KAJdU,WAIsCT,SAG7DU,aAAU,cACJF,EAAgB,KAOZG,EAAQC,YAAW,WACvBX,MACCE,UACI,WACLU,aAAaF,OAGhB,CAACV,EAAYO,EAAgBL,IAEzB,CAACG,EAAK,CAAEC,QAAAA"}