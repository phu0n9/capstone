{"version":3,"file":"react-infinite-scroll-hook.esm.js","sources":["../src/useInfiniteScroll.ts"],"sourcesContent":["import { useEffect } from 'react';\r\nimport {\r\n  useTrackVisibility,\r\n  IntersectionObserverHookArgs,\r\n  IntersectionObserverHookRefCallback,\r\n  IntersectionObserverHookRootRefCallback,\r\n} from 'react-intersection-observer-hook';\r\n\r\nconst DEFAULT_DELAY_IN_MS = 100;\r\n\r\nexport type UseInfiniteScrollHookResult = [\r\n  IntersectionObserverHookRefCallback,\r\n  { rootRef: IntersectionObserverHookRootRefCallback },\r\n];\r\n\r\nexport type UseInfiniteScrollHookArgs = Pick<\r\n  IntersectionObserverHookArgs,\r\n  // We pass this to 'IntersectionObserver'. We can use it to configure when to trigger 'onLoadMore'.\r\n  'rootMargin'\r\n> & {\r\n  // Some sort of \"is fetching\" info of the request.\r\n  loading: boolean;\r\n  // If the list has more items to load.\r\n  hasNextPage: boolean;\r\n  // The callback function to execute when the 'onLoadMore' is triggered.\r\n  // eslint-disable-next-line no-undef\r\n  onLoadMore: VoidFunction;\r\n  // Flag to stop infinite scrolling. Can be used in case of an error etc too.\r\n  disabled?: boolean;\r\n  // How long it should wait before triggering 'onLoadMore'.\r\n  delayInMs?: number;\r\n};\r\n\r\nfunction useInfiniteScroll({\r\n  loading,\r\n  hasNextPage,\r\n  onLoadMore,\r\n  rootMargin,\r\n  disabled,\r\n  delayInMs = DEFAULT_DELAY_IN_MS,\r\n}: UseInfiniteScrollHookArgs): UseInfiniteScrollHookResult {\r\n  const [ref, { rootRef, isVisible }] = useTrackVisibility({\r\n    rootMargin,\r\n  });\r\n\r\n  const shouldLoadMore = !disabled && !loading && isVisible && hasNextPage;\r\n\r\n  // eslint-disable-next-line consistent-return\r\n  useEffect(() => {\r\n    if (shouldLoadMore) {\r\n      // When we trigger 'onLoadMore' and new items are added to the list,\r\n      // right before they become rendered on the screen, 'loading' becomes false\r\n      // and 'isVisible' can be true for a brief time, based on the scroll position.\r\n      // So, it triggers 'onLoadMore' just after the first one is finished.\r\n      // We use a small delay here to prevent this kind of situations.\r\n      // It can be configured by hook args.\r\n      const timer = setTimeout(() => {\r\n        onLoadMore();\r\n      }, delayInMs);\r\n      return () => {\r\n        clearTimeout(timer);\r\n      };\r\n    }\r\n  }, [onLoadMore, shouldLoadMore, delayInMs]);\r\n\r\n  return [ref, { rootRef }];\r\n}\r\n\r\nexport default useInfiniteScroll;\r\n"],"names":["DEFAULT_DELAY_IN_MS","useInfiniteScroll","loading","hasNextPage","onLoadMore","rootMargin","disabled","delayInMs","useTrackVisibility","ref","rootRef","isVisible","shouldLoadMore","useEffect","timer","setTimeout","clearTimeout"],"mappings":";;;AAQA,IAAMA,mBAAmB,GAAG,GAA5B;;AAyBA,SAASC,iBAAT;MACEC,eAAAA;MACAC,mBAAAA;MACAC,kBAAAA;MACAC,kBAAAA;MACAC,gBAAAA;4BACAC;MAAAA,wCAAYP;;4BAE0BQ,kBAAkB,CAAC;AACvDH,IAAAA,UAAU,EAAVA;AADuD,GAAD;MAAjDI;;MAAOC,+BAAAA;MAASC,iCAAAA;;AAIvB,MAAMC,cAAc,GAAG,CAACN,QAAD,IAAa,CAACJ,OAAd,IAAyBS,SAAzB,IAAsCR,WAA7D;;AAGAU,EAAAA,SAAS,CAAC;AACR,QAAID,cAAJ,EAAoB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,UAAME,KAAK,GAAGC,UAAU,CAAC;AACvBX,QAAAA,UAAU;AACX,OAFuB,EAErBG,SAFqB,CAAxB;AAGA,aAAO;AACLS,QAAAA,YAAY,CAACF,KAAD,CAAZ;AACD,OAFD;AAGD;AACF,GAfQ,EAeN,CAACV,UAAD,EAAaQ,cAAb,EAA6BL,SAA7B,CAfM,CAAT;AAiBA,SAAO,CAACE,GAAD,EAAM;AAAEC,IAAAA,OAAO,EAAPA;AAAF,GAAN,CAAP;AACD;;;;"}