{"ast":null,"code":"/*\nCopyright (c) 2019 Daybrush\nname: framework-utils\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/framework-utils.git\nversion: 1.1.0\n*/\nfunction prefixNames(prefix) {\n  var classNames = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    classNames[_i - 1] = arguments[_i];\n  }\n\n  return classNames.map(function (className) {\n    return className.split(\" \").map(function (name) {\n      return name ? \"\" + prefix + name : \"\";\n    }).join(\" \");\n  }).join(\" \");\n}\n\nfunction prefixCSS(prefix, css) {\n  return css.replace(/([^}{]*){/gm, function (_, selector) {\n    return selector.replace(/\\.([^{,\\s\\d.]+)/g, \".\" + prefix + \"$1\") + \"{\";\n  });\n}\n/* react */\n\n\nfunction ref(target, name) {\n  return function (e) {\n    e && (target[name] = e);\n  };\n}\n\nfunction refs(target, name, i) {\n  return function (e) {\n    e && (target[name][i] = e);\n  };\n}\n/* Class Decorator */\n\n\nfunction Properties(properties, action) {\n  return function (component) {\n    var prototype = component.prototype;\n    properties.forEach(function (property) {\n      action(prototype, property);\n    });\n  };\n}\n/* Property Decorator */\n\n\nfunction withMethods(methods, duplicate) {\n  if (duplicate === void 0) {\n    duplicate = {};\n  }\n\n  return function (prototype, propertyName) {\n    methods.forEach(function (name) {\n      var methodName = duplicate[name] || name;\n\n      if (methodName in prototype) {\n        return;\n      }\n\n      prototype[methodName] = function () {\n        var _a;\n\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var result = (_a = this[propertyName])[name].apply(_a, args);\n\n        if (result === this[propertyName]) {\n          return this;\n        } else {\n          return result;\n        }\n      };\n    });\n  };\n}\n\nexport { Properties, prefixCSS, prefixNames, ref, refs, withMethods };","map":{"version":3,"sources":["../src/index.ts"],"names":["prefixNames","prefix","classNames","name","prefixCSS","css","selector","ref","target","e","refs","i","Properties","properties","action","prototype","component","withMethods","methods","duplicate","methodName","args","result"],"mappings":";;;;;;;;SAAgBA,W,CAAYC,M,EAAAA;mBAAgBC,E;;OAAAA,IAAAA,EAAAA,GAAAA,C,EAAAA,EAAAA,GAAAA,SAAAA,CAAAA,M,EAAAA,EAAAA,E,EAAAA;AAAAA,IAAAA,UAAAA,CAAAA,EAAAA,GAAAA,CAAAA,CAAAA,GAAAA,SAAAA,CAAAA,EAAAA,CAAAA;;;SACjC,UAAU,CAAV,GAAA,CACE,UAAA,SAAA,EAAA;WACD,SAAS,CAAT,KAAA,CAAA,GAAA,EAAA,GAAA,CAES,UAAA,IAAA,EAAA;aAAWC,IAAI,GAAG,KAAA,MAAA,GAAH,IAAA,GAAL,E;AAFnB,KAAA,EAAA,IAAA,CAAA,GAAA,C;AAFD,GAAA,EAAA,IAAA,CAAP,GAAO,C;;;AAUX,SAAgBC,SAAhB,CAA0BH,MAA1B,EAA0CI,GAA1C,EAA0CA;SAC/B,GAAG,CAAH,OAAA,CAAA,aAAA,EAA2B,UAAA,CAAA,EAAA,QAAA,EAAA;WACpBC,QAAQ,CAARA,OAAAA,CAAAA,kBAAAA,EAAqC,MAAA,MAAA,GAArCA,IAAAA,IAAV,G;AADJ,GAAO,C;;;;;AAMX,SAAgBC,GAAhB,CAAoBC,MAApB,EAAiCL,IAAjC,EAAiCA;SACtB,UAAA,CAAA,EAAA;AACHM,IAAAA,CAAC,KAAKD,MAAM,CAANA,IAAM,CAANA,GAANC,CAAC,CAADA;AADJ,G;;;AAIJ,SAAgBC,IAAhB,CAAqBF,MAArB,EAAkCL,IAAlC,EAAgDQ,CAAhD,EAAgDA;SACrC,UAAA,CAAA,EAAA;AACHF,IAAAA,CAAC,KAAKD,MAAM,CAANA,IAAM,CAANA,CAAAA,CAAAA,IAANC,CAAC,CAADA;AADJ,G;;;;;AAMJ,SAAgBG,UAAhB,CACIC,UADJ,EAEIC,MAFJ,EAEIA;SAEO,UAAA,SAAA,EAAA;QACGC,SAAS,GAAGC,SAAS,CAA3B,S;AAEAH,IAAAA,UAAU,CAAVA,OAAAA,CAAmB,UAAA,QAAA,EAAA;AACfC,MAAAA,MAAM,CAAA,SAAA,EAANA,QAAM,CAANA;AADJD,KAAAA;AAHJ,G;;;;;AAUJ,SAAgBI,WAAhB,CACIC,OADJ,EAEIC,SAFJ,EAEIA;yBAAAA,C,EAAAA;AAAAA,IAAAA,SAAAA,GAAAA,EAAAA;;;SAEO,UAAA,SAAA,EAAA,YAAA,EAAA;AACHD,IAAAA,OAAO,CAAPA,OAAAA,CAAgB,UAAA,IAAA,EAAA;UACNE,UAAU,GAAGD,SAAS,CAATA,IAAS,CAATA,IAAnB,I;;UAEIC,UAAU,IAAd,S,EAA6B;;;;AAG7BL,MAAAA,SAAS,CAATA,UAAS,CAATA,GAAwB,YAAA;;;mBAAUM,E;;aAAAA,IAAAA,EAAAA,GAAAA,C,EAAAA,EAAAA,GAAAA,SAAAA,CAAAA,M,EAAAA,EAAAA,E,EAAAA;AAAAA,UAAAA,IAAAA,CAAAA,EAAAA,CAAAA,GAAAA,SAAAA,CAAAA,EAAAA,CAAAA;;;YACxBC,MAAM,GAAG,CAAA,EAAA,GAAA,KAAA,YAAA,CAAA,EAAA,IAAA,EAAA,KAAA,CAAA,EAAA,EAAf,IAAe,C;;YAEXA,MAAM,KAAK,KAAf,YAAe,C,EAAoB;iBAC/B,I;AADJ,S,MAEO;iBACH,M;;AANRP,OAAAA;AANJG,KAAAA;AADJ,G","sourcesContent":["export function prefixNames(prefix: string, ...classNames: string[]) {\n    return classNames\n        .map((className) =>\n            className\n                .split(\" \")\n                .map((name) => (name ? `${prefix}${name}` : \"\"))\n                .join(\" \")\n        )\n        .join(\" \");\n}\n\nexport function prefixCSS(prefix: string, css: string) {\n    return css.replace(/([^}{]*){/gm, (_, selector) => {\n        return `${selector.replace(/\\.([^{,\\s\\d.]+)/g, `.${prefix}$1`)}{`;\n    });\n}\n\n/* react */\nexport function ref(target: any, name: string) {\n    return (e: any) => {\n        e && (target[name] = e);\n    };\n}\nexport function refs(target: any, name: string, i: number) {\n    return (e: any) => {\n        e && (target[name][i] = e);\n    };\n}\n\n/* Class Decorator */\nexport function Properties(\n    properties: any[],\n    action: (prototype: any, property: string) => any\n) {\n    return (component: any) => {\n        const prototype = component.prototype;\n\n        properties.forEach((property) => {\n            action(prototype, property);\n        });\n    };\n}\n\n/* Property Decorator */\nexport function withMethods(\n    methods: readonly string[],\n    duplicate: { [name: string]: string } = {}\n) {\n    return (prototype: any, propertyName: string) => {\n        methods.forEach((name) => {\n            const methodName = duplicate[name] || name;\n\n            if (methodName in prototype) {\n                return;\n            }\n            prototype[methodName] = function (...args) {\n                const result = this[propertyName][name](...args);\n\n                if (result === this[propertyName]) {\n                    return this;\n                } else {\n                    return result;\n                }\n            };\n        });\n    };\n}\n\nexport type ParametersType<Func, Return> = Func extends (\n    ...params: infer Params\n) => any\n    ? (...params: Params) => Return\n    : never;\n\nexport type ExcludeInterface<Obj1, Obj2> = {\n    [key in Exclude<keyof Obj1, keyof Obj2>]: Obj1[key];\n};\n\nexport type EntriesObject<T> = {\n    [key in keyof T]: [key, Readonly<T[key]>];\n};\nexport type FindKey<E, V> = E extends [infer U, V] ? U & string : never;\nexport type InvertObject<\n    T extends Record<string, any>,\n    En extends Record<string, any> = EntriesObject<T>\n    > = {\n        [key in En[keyof En][1]]: FindKey<En[keyof En], key>\n    };\n\nexport type Entries<\n    Obj extends { [key: string]: any },\n    Key = keyof Obj\n> = Key extends string ? [Key, Obj[Key]] : never;\n\nexport type ReverseKey<\n    Key extends string,\n    Obj extends { [key: string]: any },\n    E = Entries<Obj>\n> = E extends [infer Value, Key] ? Value : never;\n\nexport type UniqueMethodInterface<\n    Methods,\n    Target extends Methods,\n    ReturnTarget extends any,\n    Duplicate extends { [key: string]: any }\n> = {\n    [key in keyof ExcludeInterface<Methods, Duplicate>]: Methods[key] extends (\n        ...params: any[]\n    ) => Target\n        ? ParametersType<Methods[key], ReturnTarget>\n        : Methods[key];\n};\n\nexport type ChangedMethodInterface<\n    Methods,\n    Target extends Methods,\n    ReturnTarget extends any,\n    Duplicate extends { [key: string]: any }\n> = {\n    [key in Duplicate[keyof Duplicate]]: Methods[ReverseKey<key, Duplicate> &\n        keyof Methods] extends (...params: any[]) => Target\n        ? ParametersType<\n              Methods[ReverseKey<key, Duplicate> & keyof Methods],\n              ReturnTarget\n          >\n        : Methods[ReverseKey<key, Duplicate> & keyof Methods];\n};\n\nexport type MethodInterface<\n    Methods,\n    Target extends Methods,\n    ReturnTarget extends any,\n    Duplicate extends { [key: string]: any } = {}\n> = UniqueMethodInterface<Methods, Target, ReturnTarget, Duplicate> &\n    ChangedMethodInterface<Methods, Target, ReturnTarget, Duplicate>;\n"]},"metadata":{},"sourceType":"module"}